"use strict";(self.webpackChunk_openfn_docs=self.webpackChunk_openfn_docs||[]).push([[21058],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}},77579:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"jobs/understanding","title":"A closer look at jobs","description":"This is technical documentation aimed at making complex custom jobs easier to","source":"@site/versioned_docs/version-legacy/jobs/understanding.md","sourceDirName":"jobs","slug":"/jobs/understanding","permalink":"/documentation/legacy/jobs/understanding","draft":false,"unlisted":false,"editUrl":"https://github.com/openfn/docs/edit/main/versioned_docs/version-legacy/jobs/understanding.md","tags":[],"version":"legacy","frontMatter":{"title":"A closer look at jobs"},"sidebar":"docs","previous":{"title":"Designing a job","permalink":"/documentation/legacy/jobs/job-design-intro"},"next":{"title":"What\'s an operation?","permalink":"/documentation/legacy/jobs/operations"}}');var o=t(74848),i=t(28453);const a={title:"A closer look at jobs"},r=void 0,c={},l=[{value:"Key Terms and Concepts",id:"key-terms-and-concepts",level:2},{value:"State is passed to operations. Operations Return state.",id:"state-is-passed-to-operations-operations-return-state",level:2},{value:"Sequences of operations inside custom functions.",id:"sequences-of-operations-inside-custom-functions",level:2},{value:"Controlling timing between operations with async functions.",id:"controlling-timing-between-operations-with-async-functions",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"This is technical documentation aimed at making complex custom jobs easier to\nwrite."}),"\n",(0,o.jsx)(n.h2,{id:"key-terms-and-concepts",children:"Key Terms and Concepts"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"core"})," (",(0,o.jsx)(n.a,{href:"https://github.com/openfn/core",children:"https://github.com/openfn/core"}),") is the Javascript program which\nexecutes jobs for OpenFn in an emphemeral Node.js environment."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"state"})," is a .JSON file that is built and passed into the Node environment.\nIt contains at least two keys, ",(0,o.jsx)(n.code,{children:"configuration"})," and ",(0,o.jsx)(n.code,{children:"data"}),". Configuration will\nbe populated with your credential and it used by adaptors for authentication,\nand data will be populated with message data if the job was triggered by an\nincoming message."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "configuration": {\n    "username": "taylor",\n    "password": "shhhhhh",\n    "loginUrl": "https://login.salesforce.com"\n  },\n  "data": {\n    "a": 1,\n    "b": {\n      "x": [1, 2, 3]\n    }\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.ol,{start:"3",children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"expressions"}),' are sequences of operations to be executed. They are part of\n"jobs", which also include a credential, a trigger, a label, and (sometimes)\na github filepath.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"operations"})," are named functions, exported for use by specific adaptors,\nwhich take state and return state."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"state-is-passed-to-operations-operations-return-state",children:"State is passed to operations. Operations Return state."}),"\n",(0,o.jsx)(n.p,{children:"This is a key concept. When you write:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"create('object', fields(\n  field(...)\n));\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The execute function in your language-package (e.g., ",(0,o.jsx)(n.code,{children:"language-salesforce"}),") will\nexecute each operation with state, then return state. If you want to execute\noperations inside another custom function, you must explicitly pass in state."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"fn(state => {\n  return create('object', fields(\n    field(...)\n  ))(state)\n});\n"})}),"\n",(0,o.jsx)(n.h2,{id:"sequences-of-operations-inside-custom-functions",children:"Sequences of operations inside custom functions."}),"\n",(0,o.jsxs)(n.p,{children:["Using ",(0,o.jsx)(n.code,{children:"execute"})," you can string together several sequential operations inside a\ncustom function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'fn(state => {\n  const { userName } = state.data.form.meta;\n\n  if (userName != \'tester\') {\n    return execute(\n      upsert("person__c", "Name", fields(\n        field(...),\n        field(...)\n      )),\n      beta.each(\n        dataPath("form.array[*]"),\n        upsert("object", "Name", fields(\n          field(...)\n        ))\n      )\n    )(state)\n  }\n  return state;\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"controlling-timing-between-operations-with-async-functions",children:"Controlling timing between operations with async functions."}),"\n",(0,o.jsxs)(n.p,{children:["To get really complex, you might want to execute a number of async functions\ninside an ",(0,o.jsx)(n.code,{children:"alterState"})," operation, but WAIT for those functions to resolve before\nmoving on to your next operation. If ",(0,o.jsx)(n.code,{children:"execute"})," doesn't work for your use case,\nyou could use ",(0,o.jsx)(n.code,{children:"Promise.all"})," and return an async function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"fn(state => {\n  console.log('Here we will await the result of a LOT of async operations.');\n  console.log('First we define a bunch of different async functions.');\n  const postClinics = async c => {\n    return post(state.configuration.inboxUrl, {\n      body: { clinics: c },\n    })(state);\n  };\n\n  const postPatients = async p => {\n    return post(state.configuration.inboxUrl, {\n      body: { patients: p },\n    })(state);\n  };\n\n  const postVisits = async v => {\n    return post(state.configuration.inboxUrl, {\n      body: { visits: v },\n    })(state);\n  };\n\n  console.log(\n    'Then we define a single function that wraps them all up and waits for all the individual functions to resolve.'\n  );\n  async function makePosts() {\n    return Promise.all([\n      ...state.data.clinicSets.map(item => postClinics(item)),\n      ...state.data.patientSets.map(item => postPatients(item)),\n      ...state.data.visitSets.map(item => postVisits(item)),\n    ]);\n  }\n\n  console.log(\n    'Then we return that function, forcing our next operation to await the result of this one.'\n  );\n  return makePosts();\n});\n\nfn(state => {\n  console.log('I get called AFTER those async functions are resolved.');\n  return state;\n});\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);