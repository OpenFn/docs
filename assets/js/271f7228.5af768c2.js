"use strict";(self.webpackChunk_openfn_docs=self.webpackChunk_openfn_docs||[]).push([[62630],{18244:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(58168),s=(n(96540),n(15680));const o={layout:"post",title:"Sync Like You Mean It: Thinking Through System \u201cSyncing\u201d Protocols",author:"Jed Goldstein",author_url:"https://github.com/jedbgold",author_image_url:"https://avatars.githubusercontent.com/jedbgold",tags:["how-to","tips"],featured:!0},r=void 0,i={permalink:"/articles/2021/02/17/syncing-options",editUrl:"https://github.com/openfn/docs/edit/main/articles/2021-02-17-syncing-options.md",source:"@site/articles/2021-02-17-syncing-options.md",title:"Sync Like You Mean It: Thinking Through System \u201cSyncing\u201d Protocols",description:"\u201cSyncing\u201d is getting two systems to a state of harmony. This might mean keeping",date:"2021-02-17T00:00:00.000Z",formattedDate:"February 17, 2021",tags:[{label:"how-to",permalink:"/articles/tags/how-to"},{label:"tips",permalink:"/articles/tags/tips"}],readingTime:3.535,hasTruncateMarker:!0,authors:[{name:"Jed Goldstein",url:"https://github.com/jedbgold",imageURL:"https://avatars.githubusercontent.com/jedbgold"}],frontMatter:{layout:"post",title:"Sync Like You Mean It: Thinking Through System \u201cSyncing\u201d Protocols",author:"Jed Goldstein",author_url:"https://github.com/jedbgold",author_image_url:"https://avatars.githubusercontent.com/jedbgold",tags:["how-to","tips"],featured:!0},prevItem:{title:"Forms and Cases: CommCare and event-based integration",permalink:"/articles/2021/05/24/commcare-events"},nextItem:{title:"Our Servers or Yours: Thinking through deployment options",permalink:"/articles/2021/02/03/hosted-or-local-deployment"}},l={authorsImageUrls:[void 0]},c=[{value:"Real Time/Event Based Syncs",id:"real-timeevent-based-syncs",level:3},{value:"Scheduled Syncs",id:"scheduled-syncs",level:3},{value:"Both Sync Options Have Their Pros and Cons",id:"both-sync-options-have-their-pros-and-cons",level:3}],h={toc:c},d="wrapper";function p(e){let{components:t,...o}=e;return(0,s.yg)(d,(0,a.A)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"\u201cSyncing\u201d is getting two systems to a state of harmony. This might mean keeping\na list of patients up to date, though modifications can be made in either\nsystem. It might mean copying transactions from one system to another on a\nnightly basis. It might mean a lot of things, but the key concept is that when\nyou sync systems, you\u2019re asking them to work together while simultaneously\nrespecting both software systems\u2019 independence."),(0,s.yg)("p",null,"In this post we\u2019ll discuss two different syncing protocols to consider when\ndesigning your data integration. These include:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"Real-time, or event-based, syncs")),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("strong",{parentName:"li"},"Scheduled syncs"))),(0,s.yg)("p",null,"For a\n",(0,s.yg)("a",{parentName:"p",href:"https://www.openfn.org/spotlight/2021-02-09-interoperability-for-case-referrals"},"recent project in Cambodia"),",\nOpenFn is being used by social workers to automate case referrals between the\nsoftware systems Primero and OSCaR. In the design phase, we evaluated these two\nsyncing options. Below, we'll explain what each one is, the differences between\nthem and which option we chose in the end."),(0,s.yg)("h3",{id:"real-timeevent-based-syncs"},"Real Time/Event Based Syncs"),(0,s.yg)("p",null,"The first option considered for this integration was the real-time/event based\nsync. This type of sync is triggered whenever a specified event takes place in a\nsystem. With this approach, whenever a case is referred in Primero (via the user\ninterface, i.e., when a real case-worker clicks the \u201crefer\u201d button) OpenFn\nreceives a small payload with case data and transmits it to OSCaR and vice\nversa."),(0,s.yg)("p",null,(0,s.yg)("img",{alt:"Real_Time_Sync",src:n(91852).A,width:"1710",height:"716"})),(0,s.yg)("p",null,"Because of their instantaneous nature, real time/event based syncs are great for\nintegrations that involve mobile payments or sms messages to recipients. Really,\nanything that needs to be done \u201cnow\u201d! Additionally, depending on your data\nvolumes real time syncs might save you money because you\u2019re only using resources\nwhen specific events take place. For instance, in the above example, a run is\ntriggered by a referral, so if there are only 10 case referrals/month, you'd\nonly process 10 runs each month."),(0,s.yg)("p",null,"This type of sync is great because it\u2019s instantaneous, typically quite\nstraightforward to set up, doesn\u2019t require any \u201cstate mangagement\u201d on OpenFn,\nand allows for the reprocessing of individual events. There are, however,\ndrawbacks."),(0,s.yg)("p",null,"For instance, what happens if the app that\u2019s sending notifications to OpenFn\nfails to send? What if AWS or GCP goes down, taking half of the internet with\nit? If Primero \u201cthinks\u201d it sent the referral, OpenFn never receives it, that\ncase might not get referred to Oscar!"),(0,s.yg)("h3",{id:"scheduled-syncs"},"Scheduled Syncs"),(0,s.yg)("p",null,(0,s.yg)("img",{alt:"Schedule_Dependent_Sync",src:n(11911).A,width:"1710",height:"946"})),(0,s.yg)("p",null,"The second option considered, a bi-directional schedule dependent sync, solves\nfor the issue discussed above. On a scheduled basis (every 5 minutes, for\nexample) OpenFn checks with Primero and Oscar to see if case referrals need to\nbe transmitted between the two systems and then refers the case if required. In\nthe unlikely event that any of the software systems involved crash, the\nstability provided by the bi-directional sync means that all data is preserved\nand eventually makes it to its destination safely."),(0,s.yg)("p",null,"The major drawback here is complexity. We had to use 4 jobs instead of 2, and\nthe job that is responsible for \u201cpulling\u201d data that\u2019s been updated since the\ntime of the last successful sync has to keep \u201cstate\u201d\u2014or some sort of working\nmemory of what it\u2019s done in the past. When pulling modified cases from Primero,\nOpenFn now only pulls cases modified on or after ",(0,s.yg)("inlineCode",{parentName:"p"},"YYYY-MM-DD HH:MM:SS")," where\n",(0,s.yg)("inlineCode",{parentName:"p"},"YYYY-MM-DD HH:MM:SS")," is the time of the last successful, round-trip\nsynchronization. OpenFn has built-in functionality to handle exactly this\nrequirement, but not all ETL systems do and it\u2019s a design implication that must\nbe considered."),(0,s.yg)("p",null,"Ultimately, for the project in Cambodia, we decided that this sync option is the\nright choice because data integrity is more important than the speed of this\ndata flow. That\u2019s a crucial point to understand\u2014the organizations operating in\nCambodia decided that for this particular use case, being able to guarantee\neventual syncing was more important than having real-time syncing."),(0,s.yg)("h3",{id:"both-sync-options-have-their-pros-and-cons"},"Both Sync Options Have Their Pros and Cons"),(0,s.yg)("p",null,"Both options definitely have their use-cases and OpenFn's platform versatility\nenables your team to decide which type of sync is right for your project."),(0,s.yg)("p",null,"As always, we are here to help with any questions as you think through which\nsync option makes the most sense for your project."))}p.isMDXComponent=!0},15680:(e,t,n)=>{n.d(t,{xA:()=>h,yg:()=>y});var a=n(96540);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),d=c(n),u=s,y=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return n?a.createElement(y,r(r({ref:t},h),{},{components:n})):a.createElement(y,r({ref:t},h))}));function y(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,r=new Array(o);r[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:s,r[1]=i;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},91852:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/syncs1-ea2cb66ff0b77bf6d05e49e59af62c63.png"},11911:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/syncs2-c01d653dc6deb4939ad55425e02ba993.png"}}]);