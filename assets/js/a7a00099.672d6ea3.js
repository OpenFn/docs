"use strict";(self.webpackChunk_openfn_docs=self.webpackChunk_openfn_docs||[]).push([[90866],{19952:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"build/collections","title":"Collections","description":"Collections provides a high-volume, high-performance storage solution built into","source":"@site/docs/build/collections.md","sourceDirName":"build","slug":"/build/collections","permalink":"/documentation/build/collections","draft":false,"unlisted":false,"editUrl":"https://github.com/openfn/docs/edit/main/docs/build/collections.md","tags":[],"version":"current","frontMatter":{"title":"Collections","sidebar_label":"Collections"},"sidebar":"docs","previous":{"title":"Credentials","permalink":"/documentation/build/credentials"},"next":{"title":"Limits","permalink":"/documentation/build/limits"}}');var i=t(74848),o=t(28453);const a={title:"Collections",sidebar_label:"Collections"},l=void 0,r={},c=[{value:"Use Cases",id:"use-cases",level:2},{value:"Buffering Data",id:"buffering-data",level:3},{value:"Mapping Structures",id:"mapping-structures",level:3},{value:"Collections Basics",id:"collections-basics",level:2},{value:"Managing Collections",id:"managing-collections",level:2},{value:"Using Collections",id:"using-collections",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Collections provides a high-volume, high-performance storage solution built into\nOpenFn. Check out\n",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://www.youtube.com/watch?v=iXkkkzratzY&t=3s&ab_channel=OpenFn.org",children:"this video"})}),"\nfor an introduction."]}),"\n",(0,i.jsx)(n.p,{children:"Collections is suitable for buffering, caching and aggregating data from\nWebhooks, storing large mapping files, and sharing state between workflows."}),"\n",(0,i.jsx)(n.p,{children:"Collections can be used to store a very large number of items (in the order of\nmillions)."}),"\n",(0,i.jsxs)(n.admonition,{title:"Collections Stability",type:"caution",children:[(0,i.jsx)(n.p,{children:"Collections is a new feature to OpenFn, in beta release since November 2024."}),(0,i.jsxs)(n.p,{children:["We'd love to hear your feedback on\n",(0,i.jsx)(n.a,{href:"https://community.openfn.org/",children:"community.openfn.org"})," via email at\n",(0,i.jsx)(n.a,{href:"mailto:support@openfn.org",children:"support@openfn.org"}),"."]})]}),"\n",(0,i.jsx)(n.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(n.h3,{id:"buffering-data",children:"Buffering Data"}),"\n",(0,i.jsx)(n.p,{children:"Many OpenFn integrations are triggered through a webhook, called from another\nsystem based on some event. For example, every time a patient is registered, a\nwebhook calls into OpenFn to trigger a workflow and propagate the registration\nevent to other systems."}),"\n",(0,i.jsx)(n.p,{children:"Collections can be used as a buffer for these incoming events, saving the event\ndata on OpenFn and then processing a batch of events at the end of the day. This\nis particularly useful in high volume events, or when limits are imposed on\nupstream systems."}),"\n",(0,i.jsx)(n.p,{children:"With Collections, you can save each incoming event onto OpenFn, then run a\nWorkflow on a Cron trigger to process a batch of events in one go, and send on\naggregated, filtered or transformed results to the next system."}),"\n",(0,i.jsx)(n.h3,{id:"mapping-structures",children:"Mapping Structures"}),"\n",(0,i.jsx)(n.p,{children:"A typical use-case is data integrations is to store large mapping objects. These\nobjects themselves are key-value pairs which map strings from one system into\nmatching strings from another system. For example, mapping medical codes into\nSNOMED, or mapping city codes into human-readable strings, or mappings some\ninput string to a DHIS2 attribute code."}),"\n",(0,i.jsx)(n.p,{children:"These objects are often very large and hard to maintain, and can bloat job code."}),"\n",(0,i.jsx)(n.p,{children:"Instead, the mappings can be saved to a GitHub repository as a JSON object, and\nuploaded to a collection using the CLI."}),"\n",(0,i.jsx)(n.h2,{id:"collections-basics",children:"Collections Basics"}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsx)(n.p,{children:"The Collections API is automatically available to all Workflows and does not\nrequire any credentials. Authentication with the OpenFn platform is managed for\nyou."}),(0,i.jsx)(n.p,{children:"You can use the Collections API with any adaptor."})]}),"\n",(0,i.jsx)(n.p,{children:"Data is stored as key-value pairs, where the key is a unique identifier for some\ndata (like a UUID, or timestamp). The value is always saved as a string\n(although you can pass JSON-compatible objects directly, which will be\nautomatically serialized by the Collections API)."}),"\n",(0,i.jsxs)(n.p,{children:["Keys can be fetched in bulk and filtered by ",(0,i.jsx)(n.em,{children:"pattern"}),". For example, the pattern\n",(0,i.jsx)(n.code,{children:"2024*"})," will match all keys which start with ",(0,i.jsx)(n.code,{children:"2024"}),". Designing keys to have an\nefficient sort order is critical for high-volume Collections applications."]}),"\n",(0,i.jsxs)(n.p,{children:["The example below fetches values from the ",(0,i.jsx)(n.code,{children:"openfn-patient-registrations"}),"\ncollection and saves them onto state for further processing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"collections.get('openfn-patient-registrations', '2024*').then(state => {\n  state.registrationsThisYear = state.data;\n  return state;\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Returned items are written to state.data as an array of ",(0,i.jsx)(n.code,{children:"[{ key, value }]"}),"\npairs:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n  "data": {\n    "20240102-5901257": {\n      "name": "Tom Waits",\n      "id": "5901257",\n    },\n    "20240213-0183216": {\n      "name": "Billie Holiday",\n      "id": "0183216",\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If fetching a single item (i.e. no ",(0,i.jsx)(n.code,{children:"*"})," in the key), it will be written directly\nto ",(0,i.jsx)(n.code,{children:"state.data"})," with no key:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'{\n  "data": {\n    "name": "Billie Holiday",\n    "id": "0183216",\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Every key permanently saves its creation date, so as well as fetching by\nkey-pattern, you can also filter keys by date. This example fetches all keys\ncreated before 30th September 2024:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"collections\n  .get('openfn-patient-registrations', '*', { createdBefore: '2024-09-30' })\n  .then(state => {\n    state.registrationsThisYear = state.data;\n    return state;\n  });\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"collections.get"})," will download all matching values into memory. For large\nvalues or high-volume value sets, it is more efficient to use\n",(0,i.jsx)(n.code,{children:"collections.each"}),", which will stream each value into memory individually and\nthen discard it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"collections.each(\n  'my-collection',\n  { key: '2024*', createdAfter: '20240601' },\n  (state, value, key) => {\n    console.log(value);\n  }\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Values are uploaded to a collection through ",(0,i.jsx)(n.code,{children:"collections.set"}),'. All sets are\n"upserts" - meaning that new keys will be created for values that don\'t exist,\nand values will be updated for keys that ',(0,i.jsx)(n.em,{children:"do"})," exist."]}),"\n",(0,i.jsx)(n.p,{children:"The example below sets a single item:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"collections.set('openfn-demo', 'commcare-fhir-value-mappings', {\n  current_smoker: {\n    system: 'http://snomed.info/sct',\n    code: '77176002',\n    display: 'Smoker',\n  },\n  /* ... */\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If setting multiple values at once, pass a key generator function instead of an\nid to generate a key for each item. For example, if several value are saved in\nan array on ",(0,i.jsx)(n.code,{children:"state.data"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"collections.set('openfn-demo', (patient, state) => patient.id, $.patients);\n"})}),"\n",(0,i.jsx)(n.p,{children:"The key generator will be called with each value and must return a string key."}),"\n",(0,i.jsx)(n.h2,{id:"managing-collections",children:"Managing Collections"}),"\n",(0,i.jsx)(n.p,{children:"Collections can be created, destroyed or renamed from the Admin menu."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Collections Admin Page",src:t(21618).A+"",width:"932",height:"561"})}),"\n",(0,i.jsxs)(n.p,{children:["Before it can be used, a collection must be created. Collection names must be\nunique to the deployment, so we recommend using your organisation (and maybe\nproject) as a prefix, ie, ",(0,i.jsx)(n.code,{children:"openfn-demo"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"using-collections",children:"Using Collections"}),"\n",(0,i.jsx)(n.p,{children:"Collections are available to all Workflows via a simple high-level interface."}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsx)(n.p,{children:"A Collection must be created in the admin interface before it can be used."})}),"\n",(0,i.jsx)(n.p,{children:"The Collections API provides four basic verbs:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/adaptors/packages/collections-docs#collections_get",children:(0,i.jsx)(n.code,{children:"collections.get()"})}),"\ndownloads values matching a key or key pattern."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/adaptors/packages/collections-docs#collections_each",children:(0,i.jsx)(n.code,{children:"collections.each()"})}),"\nefficiently iterates over a range of items in a collection."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/adaptors/packages/collections-docs#collections_set",children:(0,i.jsx)(n.code,{children:"collections.set()"})}),"\nuploads values to a collection."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/adaptors/packages/collections-docs#collections_remove",children:(0,i.jsx)(n.code,{children:"collections.remove()"})}),"\nwill remove values by key or key pattern."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The Collection API is backed by a special adaptor: see the\n",(0,i.jsx)(n.a,{href:"/adaptors/collections",children:"Collections Adaptor API"})," for more details."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},21618:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/collections_admin-ae3877e4cc708006b17de8e96255efd0.webp"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(96540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);